#!/usr/bin/perl
#
# Snow Stuff For Hire - A POS-like system designed for very quick rental
# operations at small ski resorts
# Copyright (C) 2014 Mads Bondo Dydensborg <mads@dydensborg.dk>
#
# This file is part of Snow Stuff For Hire.
#
# Snow Stuff For Hire is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Snow Stuff For Hire is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Snow Stuff For Hire.  If not, see <http://www.gnu.org/licenses/>.
#

#Script to extract some database consts from the schema file and write them to files.

use warnings;
use strict;

my $scanning = "scanning";
my $output = "output";
my $state = $scanning;

my $db_strings = "";
my $consts = "";
my $next_group = "";
my $prefix = " ";

# Store struct stuff here until ready to dump it.
my %item_stuff;

while( <> ) {
    if ( $state eq $scanning ) {
        if ( m/^\s*\-\-\s*TRANSLATE:(\w+)\s*$/ ) {
#            print STDERR "Found $_";
#            print STDERR "Goes into $1\n";
            $next_group = $1;
            if ( ! defined $item_stuff{ $next_group } ) {
                $item_stuff{ $next_group } = "";
            }
            $state = $output;
        }
        next;
    }
    if ( $state eq $output ) {
        if ( m/^\s*([^\s]+)\s+text\s+check\s*\(\s*[^\s]+\s+in\s*\(\s*([^\)]+\')\s*\)\s*\)\s*\,\s*$/ ) {
#            print STDERR "Found $_";
#            print STDERR "colum $1\n";
#            print STDERR "Goes into $2\n";
            $db_strings .= "    // $1\n";
            my $column = ucfirst $1;
            $item_stuff{ $next_group } .= "        struct $column {\n";

            my $values = $2;
            $values =~ s/\'//g;
            $values =~s/\, /,/g;
            my @valuesa = split( /,\s*/, $values );
            print STDERR "valuesa : @valuesa\n"; 

            foreach ( sort @valuesa ) {
                print STDERR "Got key $_\n";
                # QT_TRANSLATE_NOOP("Item","in"),
                my $value = $_;
                my $key = $value;
                $key =~ s/ /_/g;
                $db_strings .= "    $prefix"."QT_TRANSLATE_NOOP(\"$next_group\", \"$value\" )\n";
                $prefix = ",";
                #$ITEM_STUFF .= "            static const QString $_;\n";
                $item_stuff{ $next_group} .= "            static const QString $key;\n";
                $consts .= "const QString DB::$next_group"."::$column"."::$key = \"$value\";\n";
            }
            $db_strings .= "\n";
            $item_stuff{ $next_group } .= "        };\n\n";
            $consts .= "\n";
        } else {
            die "In output state, but no match for $_";
        }
        $state = $scanning;
        next;
    }
}

# Write header and cc file. 
open( HH, ">db_consts.h" ) || die "Unable to open db_consts.h";
open( CC, ">db_consts.cpp" ) || die "Unable to open db_consts.cpp";

print HH <<EOF;
/** \\file
  * \\brief DB Constants
  * 
  * DB constants and translations, autogenerated from schema.sql 
  * by $0 */

// Qt
#include <QString>

/** \\brief Define constants in the database as constants in the program. */
struct DB {
EOF
foreach my $key (sort keys %item_stuff ) {
    print HH "    struct $key {\n$item_stuff{ $key }\n    };\n";
} 
print HH "};\n\n";

print CC <<EOF;
/** \\file
  * \\brief DB Constants
  * 
  * DB constants and translations, autogenerated from schema.sql 
  * by $0 */

// Qt
#include <QtGlobal>

// App
#include "db_consts.h"

// Values from schema.sql marked for translation
static const char * db_strings[] = {

$db_strings
};

// Const storage
$consts

EOF